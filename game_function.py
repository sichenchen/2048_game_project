# -*- coding: utf-8 -*-
"""Game_Function.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MQvBilpVf4Ye5gjBMAtf_dxB1Vhb6pej
"""

import random

def initialize_grid():
    grid = [[0]*4 for _ in range(4)]
    row1 = random.randint(0,3)
    col1 = random.randint(0,3)
    row2 = random.randint(0,3)
    col2 = random.randint(0,3)
    grid[row1][col1]=2
    while row1==row2 and col1==col2:
        row2 = random.randint(0,3)
        col2 = random.randint(0,3)
    grid[row2][col2]=2
    return grid

def print_grid(grid):
    for row in grid:
        print(" ".join(map(str,row)))

print_grid(initialize_grid())

def move_left(grid):
  for row in grid:
        non_empty = [num for num in row if num != 0]
        new_row = []
        skip = False
        for i in range(len(non_empty)):
            if skip:
                skip = False
                continue
            if i + 1 < len(non_empty) and non_empty[i] == non_empty[i + 1]:
                new_row.append(non_empty[i] * 2)
                skip = True
            else:
                new_row.append(non_empty[i])
        new_row += [0] * (4 - len(new_row))  # Fill rest with zeros
        for i in range(4):
            row[i] = new_row[i]

def move_right(grid):
    for row in grid:
        # Reverse the row to reuse move_left logic in the opposite direction
        non_empty = [num for num in reversed(row) if num != 0]
        new_row = []
        skip = False
        for i in range(len(non_empty)):
            if skip:
                skip = False
                continue
            # If two consecutive numbers are the same, merge them
            if i + 1 < len(non_empty) and non_empty[i] == non_empty[i + 1]:
                new_row.append(non_empty[i] * 2)
                skip = True  # Skip the next element since it was merged
            else:
                new_row.append(non_empty[i])
        # Fill the remaining cells with zeros on the left side
        new_row += [0] * (4 - len(new_row))
        # Reverse again to get the right-aligned row
        new_row.reverse()
        # Update the original row with the new values
        for i in range(4):
            row[i] = new_row[i]

def move_up(grid):
    for col in range(4):
        # Collect all non-zero values in the current column
        non_empty = [grid[row][col] for row in range(4) if grid[row][col] != 0]
        new_column = []
        skip = False
        for i in range(len(non_empty)):
            if skip:
                skip = False
                continue
            # If two consecutive numbers are the same, merge them
            if i + 1 < len(non_empty) and non_empty[i] == non_empty[i + 1]:
                new_column.append(non_empty[i] * 2)
                skip = True  # Skip the next element since it was merged
            else:
                new_column.append(non_empty[i])
        # Fill the remaining cells in the column with zeros at the bottom
        new_column += [0] * (4 - len(new_column))

        # Update the original grid's column with the new values
        for row in range(4):
            grid[row][col] = new_column[row]

def move_down(grid):
    for col in range(4):
        # Collect all non-zero values in the current column and reverse to start from the bottom
        non_empty = [grid[row][col] for row in range(4) if grid[row][col] != 0][::-1]
        new_column = []
        skip = False
        for i in range(len(non_empty)):
            if skip:
                skip = False
                continue
            # If two consecutive numbers are the same, merge them
            if i + 1 < len(non_empty) and non_empty[i] == non_empty[i + 1]:
                new_column.append(non_empty[i] * 2)
                skip = True  # Skip the next element since it was merged
            else:
                new_column.append(non_empty[i])
        # Fill the remaining cells in the column with zeros at the top
        new_column += [0] * (4 - len(new_column))
        # Reverse new_column back to put merged elements at the bottom
        new_column.reverse()

        # Update the original grid's column with the new values
        for row in range(4):
            grid[row][col] = new_column[row]